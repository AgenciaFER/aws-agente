#!/usr/bin/env python3
"""
Script de Configura√ß√£o de Seguran√ßa do AWS Multi-Account Agent
============================================================

Este script configura todas as medidas de seguran√ßa recomendadas
para o ambiente de produ√ß√£o.
"""

import os
import sys
import yaml
import json
import subprocess
from pathlib import Path
from typing import Dict, Any

class SecurityConfigurator:
    """Configurador de seguran√ßa para o AWS Multi-Account Agent"""
    
    def __init__(self):
        self.project_root = Path(__file__).parent.parent
        self.config_dir = self.project_root / "config"
        self.security_dir = self.project_root / "security"
        
        # Criar diret√≥rios se n√£o existirem
        self.config_dir.mkdir(exist_ok=True)
        self.security_dir.mkdir(exist_ok=True)
    
    def configure_production_security(self):
        """Configura seguran√ßa para produ√ß√£o"""
        print("üîê Configurando seguran√ßa para produ√ß√£o...")
        
        # 1. Configurar arquivo de seguran√ßa
        self.create_security_config()
        
        # 2. Configurar permiss√µes de arquivos
        self.set_file_permissions()
        
        # 3. Configurar criptografia
        self.setup_encryption()
        
        # 4. Configurar logs seguros
        self.configure_secure_logging()
        
        # 5. Configurar auditoria
        self.configure_audit_logging()
        
        # 6. Configurar alertas de seguran√ßa
        self.configure_security_alerts()
        
        # 7. Instalar ferramentas de seguran√ßa
        self.install_security_tools()
        
        print("‚úÖ Configura√ß√£o de seguran√ßa conclu√≠da!")
    
    def create_security_config(self):
        """Cria arquivo de configura√ß√£o de seguran√ßa"""
        print("üìÑ Criando arquivo de configura√ß√£o de seguran√ßa...")
        
        security_config = {
            "security": {
                "encryption": {
                    "algorithm": "AES-256-GCM",
                    "key_derivation": "PBKDF2",
                    "iterations": 150000,
                    "salt_length": 32
                },
                "session": {
                    "timeout": 1800,  # 30 minutos
                    "max_retries": 2,
                    "lockout_time": 1800,  # 30 minutos
                    "auto_refresh": True,
                    "refresh_threshold": 300  # 5 minutos
                },
                "audit": {
                    "enabled": True,
                    "log_level": "INFO",
                    "retention_days": 365,
                    "encrypt_logs": True,
                    "sanitize_logs": True
                },
                "validation": {
                    "strict_mode": True,
                    "validate_permissions": True,
                    "check_resource_existence": True,
                    "require_mfa": False  # Pode ser habilitado se necess√°rio
                },
                "network": {
                    "force_tls": True,
                    "min_tls_version": "1.3",
                    "verify_certificates": True,
                    "timeout": 30
                },
                "monitoring": {
                    "failed_login_threshold": 3,
                    "suspicious_activity_detection": True,
                    "real_time_alerts": True,
                    "metrics_collection": True
                }
            }
        }
        
        security_file = self.config_dir / "security.yaml"
        with open(security_file, 'w') as f:
            yaml.dump(security_config, f, default_flow_style=False, indent=2)
        
        print(f"‚úÖ Arquivo de seguran√ßa criado: {security_file}")
    
    def set_file_permissions(self):
        """Define permiss√µes seguras para arquivos"""
        print("üîí Configurando permiss√µes de arquivos...")
        
        if os.name == 'posix':  # Unix/Linux/macOS
            sensitive_files = [
                "config/security.yaml",
                "config/default.yaml",
                "config/accounts.json"
            ]
            
            for file_path in sensitive_files:
                full_path = self.project_root / file_path
                if full_path.exists():
                    # Definir permiss√µes 600 (rw para owner, nada para outros)
                    os.chmod(full_path, 0o600)
                    print(f"‚úÖ Permiss√µes definidas para {file_path}")
            
            # Permiss√µes para diret√≥rios
            sensitive_dirs = [
                "config",
                "security",
                "logs"
            ]
            
            for dir_path in sensitive_dirs:
                full_path = self.project_root / dir_path
                if full_path.exists():
                    # Definir permiss√µes 700 (rwx para owner, nada para outros)
                    os.chmod(full_path, 0o700)
                    print(f"‚úÖ Permiss√µes definidas para diret√≥rio {dir_path}")
        else:
            print("‚ö†Ô∏è  Configura√ß√£o de permiss√µes n√£o suportada no Windows")
    
    def setup_encryption(self):
        """Configura sistema de criptografia"""
        print("üîê Configurando sistema de criptografia...")
        
        # Criar arquivo de configura√ß√£o de criptografia
        encryption_config = {
            "encryption": {
                "default_algorithm": "AES-256-GCM",
                "key_derivation": {
                    "method": "PBKDF2",
                    "iterations": 150000,
                    "salt_length": 32,
                    "hash_algorithm": "SHA-256"
                },
                "secure_random": {
                    "use_system_random": True,
                    "entropy_sources": ["os.urandom", "secrets"]
                }
            }
        }
        
        encryption_file = self.security_dir / "encryption.yaml"
        with open(encryption_file, 'w') as f:
            yaml.dump(encryption_config, f, default_flow_style=False, indent=2)
        
        print(f"‚úÖ Configura√ß√£o de criptografia criada: {encryption_file}")
    
    def configure_secure_logging(self):
        """Configura sistema de logs seguros"""
        print("üìù Configurando sistema de logs seguros...")
        
        # Criar diret√≥rio de logs
        logs_dir = self.project_root / "logs"
        logs_dir.mkdir(exist_ok=True)
        
        # Configura√ß√£o de logging
        logging_config = {
            "version": 1,
            "disable_existing_loggers": False,
            "formatters": {
                "secure": {
                    "format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
                    "datefmt": "%Y-%m-%d %H:%M:%S"
                },
                "audit": {
                    "format": "%(asctime)s - AUDIT - %(levelname)s - %(message)s",
                    "datefmt": "%Y-%m-%d %H:%M:%S"
                }
            },
            "handlers": {
                "file": {
                    "class": "logging.handlers.RotatingFileHandler",
                    "filename": str(logs_dir / "aws-agent.log"),
                    "maxBytes": 10485760,  # 10MB
                    "backupCount": 5,
                    "formatter": "secure",
                    "level": "INFO"
                },
                "audit": {
                    "class": "logging.handlers.RotatingFileHandler",
                    "filename": str(logs_dir / "audit.log"),
                    "maxBytes": 10485760,  # 10MB
                    "backupCount": 10,
                    "formatter": "audit",
                    "level": "INFO"
                },
                "security": {
                    "class": "logging.handlers.RotatingFileHandler",
                    "filename": str(logs_dir / "security.log"),
                    "maxBytes": 10485760,  # 10MB
                    "backupCount": 10,
                    "formatter": "audit",
                    "level": "WARNING"
                }
            },
            "loggers": {
                "aws_agent": {
                    "handlers": ["file", "audit"],
                    "level": "INFO",
                    "propagate": False
                },
                "aws_agent.security": {
                    "handlers": ["security"],
                    "level": "WARNING",
                    "propagate": False
                }
            }
        }
        
        logging_file = self.config_dir / "logging.yaml"
        with open(logging_file, 'w') as f:
            yaml.dump(logging_config, f, default_flow_style=False, indent=2)
        
        print(f"‚úÖ Configura√ß√£o de logging criada: {logging_file}")
    
    def configure_audit_logging(self):
        """Configura auditoria de a√ß√µes"""
        print("üîç Configurando auditoria de a√ß√µes...")
        
        audit_config = {
            "audit": {
                "enabled": True,
                "log_all_actions": True,
                "log_failed_attempts": True,
                "log_permission_checks": True,
                "retention_policy": {
                    "days": 365,
                    "archive_after_days": 90,
                    "compression": True
                },
                "alerts": {
                    "failed_login_threshold": 3,
                    "suspicious_activity_patterns": [
                        "multiple_failed_logins",
                        "unusual_access_patterns",
                        "privilege_escalation_attempts"
                    ]
                }
            }
        }
        
        audit_file = self.security_dir / "audit.yaml"
        with open(audit_file, 'w') as f:
            yaml.dump(audit_config, f, default_flow_style=False, indent=2)
        
        print(f"‚úÖ Configura√ß√£o de auditoria criada: {audit_file}")
    
    def configure_security_alerts(self):
        """Configura alertas de seguran√ßa"""
        print("üö® Configurando alertas de seguran√ßa...")
        
        alerts_config = {
            "alerts": {
                "channels": {
                    "email": {
                        "enabled": True,
                        "smtp_server": "smtp.gmail.com",
                        "smtp_port": 587,
                        "use_tls": True,
                        "sender": "security@exemplo.com",
                        "recipients": ["admin@exemplo.com"]
                    },
                    "slack": {
                        "enabled": False,
                        "webhook_url": "https://hooks.slack.com/services/YOUR/WEBHOOK/URL"
                    },
                    "webhook": {
                        "enabled": False,
                        "url": "https://your-webhook-endpoint.com/alerts"
                    }
                },
                "severity_levels": {
                    "low": ["info", "debug"],
                    "medium": ["warning"],
                    "high": ["error"],
                    "critical": ["critical", "security_breach"]
                },
                "rate_limiting": {
                    "enabled": True,
                    "max_alerts_per_hour": 10,
                    "cooldown_period": 300  # 5 minutos
                }
            }
        }
        
        alerts_file = self.security_dir / "alerts.yaml"
        with open(alerts_file, 'w') as f:
            yaml.dump(alerts_config, f, default_flow_style=False, indent=2)
        
        print(f"‚úÖ Configura√ß√£o de alertas criada: {alerts_file}")
    
    def install_security_tools(self):
        """Instala ferramentas de seguran√ßa"""
        print("üõ†Ô∏è Instalando ferramentas de seguran√ßa...")
        
        security_tools = [
            "bandit",       # Security linter
            "safety",       # Dependency vulnerability scanner
            "pip-audit",    # Python package auditor
        ]
        
        for tool in security_tools:
            try:
                subprocess.run([
                    sys.executable, "-m", "pip", "install", tool
                ], check=True, capture_output=True)
                print(f"‚úÖ {tool} instalado com sucesso")
            except subprocess.CalledProcessError:
                print(f"‚ùå Falha ao instalar {tool}")
    
    def create_security_scripts(self):
        """Cria scripts de seguran√ßa adicionais"""
        print("üìú Criando scripts de seguran√ßa...")
        
        # Script de verifica√ß√£o de compliance
        compliance_script = """#!/usr/bin/env python3
\"\"\"
Script de verifica√ß√£o de compliance
\"\"\"
import sys
import subprocess
from pathlib import Path

def check_compliance():
    \"\"\"Verifica compliance de seguran√ßa\"\"\"
    project_root = Path(__file__).parent.parent
    
    # Executar auditoria
    result = subprocess.run([
        sys.executable, str(project_root / "security" / "audit.py")
    ], capture_output=True, text=True)
    
    return result.returncode == 0

if __name__ == "__main__":
    if check_compliance():
        print("‚úÖ Compliance verificado com sucesso")
        sys.exit(0)
    else:
        print("‚ùå Falha na verifica√ß√£o de compliance")
        sys.exit(1)
"""
        
        compliance_file = self.security_dir / "compliance_check.py"
        with open(compliance_file, 'w') as f:
            f.write(compliance_script)
        
        # Tornar execut√°vel
        if os.name == 'posix':
            os.chmod(compliance_file, 0o755)
        
        print(f"‚úÖ Script de compliance criado: {compliance_file}")
    
    def generate_security_checklist(self):
        """Gera checklist de seguran√ßa"""
        print("üìã Gerando checklist de seguran√ßa...")
        
        checklist = """# üîê Security Checklist - AWS Multi-Account Agent

## üìã Configura√ß√£o Inicial

### üîë Credenciais
- [ ] Credenciais n√£o est√£o hardcoded no c√≥digo
- [ ] Keyring do sistema est√° configurado
- [ ] Criptografia AES-256 est√° habilitada
- [ ] Rota√ß√£o autom√°tica de tokens configurada

### üîí Permiss√µes
- [ ] Arquivos sens√≠veis com permiss√µes 600
- [ ] Diret√≥rios sens√≠veis com permiss√µes 700
- [ ] Princ√≠pio do menor privil√©gio aplicado
- [ ] Valida√ß√£o de permiss√µes habilitada

### üåê Rede
- [ ] TLS 1.3 for√ßado
- [ ] Verifica√ß√£o de certificados habilitada
- [ ] Timeouts apropriados configurados
- [ ] Proxy configurado se necess√°rio

## üîç Monitoramento

### üìù Logs
- [ ] Logging seguro configurado
- [ ] Sanitiza√ß√£o de logs habilitada
- [ ] Reten√ß√£o de logs configurada
- [ ] Criptografia de logs habilitada

### üö® Alertas
- [ ] Alertas de seguran√ßa configurados
- [ ] Canais de notifica√ß√£o configurados
- [ ] Limites de rate configurados
- [ ] Escala√ß√£o autom√°tica configurada

### üîç Auditoria
- [ ] Auditoria de a√ß√µes habilitada
- [ ] Logs de auditoria protegidos
- [ ] Reten√ß√£o de auditoria configurada
- [ ] Compliance verificado

## üõ°Ô∏è Hardening

### üîß Configura√ß√£o
- [ ] Configura√ß√£o de seguran√ßa aplicada
- [ ] Timeouts de sess√£o configurados
- [ ] Lockout por tentativas configurado
- [ ] Valida√ß√£o estrita habilitada

### üß™ Testes
- [ ] Testes de seguran√ßa executados
- [ ] Vulnerability scanning executado
- [ ] Dependency checking executado
- [ ] Penetration testing executado

## üìä Compliance

### ‚úÖ Frameworks
- [ ] OWASP Top 10 verificado
- [ ] AWS Well-Architected implementado
- [ ] PCI DSS (se aplic√°vel)
- [ ] GDPR (se aplic√°vel)

### üìà M√©tricas
- [ ] Score de compliance > 80%
- [ ] Cobertura de testes > 90%
- [ ] Zero vulnerabilidades cr√≠ticas
- [ ] Documenta√ß√£o atualizada

## üöÄ Produ√ß√£o

### üîÑ Deploy
- [ ] Secrets management configurado
- [ ] CI/CD pipeline seguro
- [ ] Backup de configura√ß√µes
- [ ] Rollback plan definido

### üìû Resposta a Incidentes
- [ ] Plano de resposta definido
- [ ] Contatos de emerg√™ncia configurados
- [ ] Procedimentos de conten√ß√£o definidos
- [ ] Comunica√ß√£o de incidentes preparada

---

*Este checklist deve ser revisado antes de cada deploy em produ√ß√£o.*
"""
        
        checklist_file = self.security_dir / "security-checklist.md"
        with open(checklist_file, 'w') as f:
            f.write(checklist)
        
        print(f"‚úÖ Checklist de seguran√ßa criado: {checklist_file}")
    
    def print_summary(self):
        """Imprime resumo da configura√ß√£o"""
        print("\n" + "="*60)
        print("üîê RESUMO DA CONFIGURA√á√ÉO DE SEGURAN√áA")
        print("="*60)
        
        print("‚úÖ Configura√ß√µes criadas:")
        print("  ‚Ä¢ config/security.yaml - Configura√ß√£o principal")
        print("  ‚Ä¢ config/logging.yaml - Configura√ß√£o de logs")
        print("  ‚Ä¢ security/encryption.yaml - Configura√ß√£o de criptografia")
        print("  ‚Ä¢ security/audit.yaml - Configura√ß√£o de auditoria")
        print("  ‚Ä¢ security/alerts.yaml - Configura√ß√£o de alertas")
        print("  ‚Ä¢ security/security-checklist.md - Checklist de seguran√ßa")
        
        print("\nüõ†Ô∏è Ferramentas de seguran√ßa instaladas:")
        print("  ‚Ä¢ bandit - Security linter")
        print("  ‚Ä¢ safety - Dependency vulnerability scanner")
        print("  ‚Ä¢ pip-audit - Python package auditor")
        
        print("\nüîí Permiss√µes configuradas:")
        if os.name == 'posix':
            print("  ‚Ä¢ Arquivos sens√≠veis: 600 (rw-------)")
            print("  ‚Ä¢ Diret√≥rios sens√≠veis: 700 (rwx------)")
        else:
            print("  ‚Ä¢ Permiss√µes n√£o configuradas (Windows)")
        
        print("\nüìã Pr√≥ximos passos:")
        print("  1. Execute: python security/audit.py")
        print("  2. Revise: security/security-checklist.md")
        print("  3. Configure alertas em: security/alerts.yaml")
        print("  4. Teste em ambiente de produ√ß√£o")
        
        print("\n" + "="*60)

def main():
    """Fun√ß√£o principal"""
    print("üîê AWS Multi-Account Agent - Security Configuration")
    print("="*55)
    
    configurator = SecurityConfigurator()
    
    # Configurar seguran√ßa
    configurator.configure_production_security()
    
    # Criar scripts adicionais
    configurator.create_security_scripts()
    
    # Gerar checklist
    configurator.generate_security_checklist()
    
    # Imprimir resumo
    configurator.print_summary()
    
    print("\n‚úÖ Configura√ß√£o de seguran√ßa conclu√≠da com sucesso!")

if __name__ == "__main__":
    main()
